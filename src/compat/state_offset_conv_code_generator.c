/* Reads a textual file, for which each line has the following format:
 *
 * <offset> <var_name>
 *
 * where offset is a 4-digit hexadecimal number (including leading zeros)
 * representing an offset into the dseg in a 16-bit DOS program, and var_name
 * is the name of a variable (of type statetype).
 *
 * WARNING: THIS PROGRAM MAY FAIL TO WORK AS EXPECTED AND REPLACE MORE OR LESS
 * THAN INTENDED (Hint: It does replace more than intended, check comments).
 *
 * THIS PROGRAM COMES WITH NO WARRANTY, EXPRESSED OR IMPLIED.
 */

#include <ctype.h>
#include <stdio.h>

#define MAX_MAPPINGS_AMOUNT 500
#define VAR_NAME_LENGTH_UPPER_BOUND 32

typedef struct {
	unsigned short offset;
	char varName[VAR_NAME_LENGTH_UPPER_BOUND];
} MapEntry;

int main(int argc, char **argv) {
	//
	MapEntry mappingTable[MAX_MAPPINGS_AMOUNT];
	//
	if (argc != 2) {
		printf("\nThis program expects input map of state 16-bit dseg offsets\nto state variable names. Outputs generated code to stdout.\n");
		return 1;
	}
	FILE *fp = fopen(argv[1], "rb");
	if (!fp) {
		printf("\nFile %s cannot be opened for reading\n", argv[1]);
		return 2;
	}
	int mapCounter = 0, readVal, i;
	MapEntry *currEntry = mappingTable;
	while (!feof(fp) && (mapCounter < MAX_MAPPINGS_AMOUNT)) {
		// Scan offset
		currEntry->offset = 0;
		for (i = 0; i < 4; ++i) {
			readVal = fgetc(fp);
			if (readVal == EOF) {
				break;
			}
			if ((readVal >= '0') && (readVal <= '9')) {
				currEntry->offset = 16*(currEntry->offset) + readVal-'0';
			} else if ((readVal >= 'A') && (readVal <= 'F')) {
				currEntry->offset = 16*(currEntry->offset) + readVal-'A'+10;
			} else if ((readVal >= 'a') && (readVal <= 'f')) {
				currEntry->offset = 16*(currEntry->offset) + readVal-'a'+10;
			} else {
				fclose(fp);
				fprintf(stderr, "\nFATAL ERROR: Line no. %d doesn't begin with 4-digit hex value, aborting\n", mapCounter);
				return 3;
			}
		}
		if (readVal == EOF) {
			break;
		}
		// Skip whitespace
		do {
			readVal = fgetc(fp);
		} while (isspace(readVal));
		// Scan variable name - USING LAST readVal VALUE FROM ABOVE
		int varNameLen = 0;
		char *varNamePtr = currEntry->varName;
		do {
			if ((readVal == EOF) || isspace(readVal)) {
				break;
			}
			*(varNamePtr++) = readVal;
			if (++varNameLen == VAR_NAME_LENGTH_UPPER_BOUND)
			{
				fclose(fp);
				*(varNamePtr-1) = '\0'; // For printing
				fprintf(stderr, "\nFATAL ERROR: Too long variable nameFile (beginning with %s, line no. %d), aborting\n", currEntry->varName, mapCounter);
				return 4;
			}
			readVal = fgetc(fp);
		} while (1);
		// DON'T FORGET THESE!
		*varNamePtr = '\0';
		++mapCounter;
		++currEntry;
		// Scan until we encounter newline (line feed)
		while ((readVal != '\n') && (readVal != EOF)) {
			readVal = fgetc(fp);
		}
		if (readVal == EOF) {
			fprintf(stderr, "\nWARNING: Encountered end-of-file before newline, this may be considered acceptable in other programs.\n");
		}
	}
	if (!feof(fp)) {
		fclose(fp);
		fprintf(stderr, "\nFATAL ERROR: Too many lines in input file (max. supported %d), aborting.\n", MAX_MAPPINGS_AMOUNT);
	}
	/*** Finally we can print our output ***/
	printf("/*** Code generated by state_offset_conv_code_generator ***/\n");
	printf("\n");
	printf("#include \"kd_def.h\"\n");
	printf("\n");
	// First declare variables with extern
	printf("// List of all statetypes\n");
	for (i = 0, currEntry = mappingTable; i < mapCounter; ++i, ++currEntry) {
		printf("extern statetype %s;\n", currEntry->varName);
	}
	// We then write function that fills such each state's new field with the original 16-bit offset
	printf("\n");
	printf("void BE_Cross_Compat_FillObjStatesWithDOSOffsets(void)\n");
	printf("{\n");
	for (i = 0, currEntry = mappingTable; i < mapCounter; ++i, ++currEntry) {
		printf("\t%s.compatdosoffset = 0x%04X;\n", currEntry->varName, currEntry->offset);
	}
	printf("}\n");
	// Finally we write a method for conversion of 16-bit offset to state pointer (for saved game loading);
	// Returns NULL if not found (which can happen if the saved value hasn't been used as a state)
	printf("\n");
	printf("void* BE_Cross_Compat_GetObjStatePtrFromDOSOffset(uint16_t offset)\n");
	printf("{\n");
	printf("\tswitch (offset)\n");
	printf("\t{\n");
	for (i = 0, currEntry = mappingTable; i < mapCounter; ++i, ++currEntry) {
		printf("\tcase 0x%04X: return &%s;\n", currEntry->offset, currEntry->varName);
	}
	printf("\t}\n");
	printf("\treturn NULL;\n");
	printf("}\n");
	return 0;
}
